// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: exercise_sets.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createExerciseSets = `-- name: CreateExerciseSets :exec
INSERT INTO exercise_sets (id, ordinal, workout_exerciseID, weight, reps, static_hold_time, created_at, modified_at)
VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    NOW(),
    NOW()
)
`

type CreateExerciseSetsParams struct {
	ID                uuid.UUID
	Ordinal           int32
	WorkoutExerciseid uuid.UUID
	Weight            float64
	Reps              sql.NullInt32
	StaticHoldTime    sql.NullInt32
}

func (q *Queries) CreateExerciseSets(ctx context.Context, arg CreateExerciseSetsParams) error {
	_, err := q.db.ExecContext(ctx, createExerciseSets,
		arg.ID,
		arg.Ordinal,
		arg.WorkoutExerciseid,
		arg.Weight,
		arg.Reps,
		arg.StaticHoldTime,
	)
	return err
}

const getExerciseSetsByExID = `-- name: GetExerciseSetsByExID :many
SELECT id, workout_exerciseid, ordinal, weight, reps, static_hold_time, created_at, modified_at
FROM
    exercise_sets
WHERE workout_exerciseID = $1
ORDER BY ordinal
`

func (q *Queries) GetExerciseSetsByExID(ctx context.Context, workoutExerciseid uuid.UUID) ([]ExerciseSet, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseSetsByExID, workoutExerciseid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExerciseSet
	for rows.Next() {
		var i ExerciseSet
		if err := rows.Scan(
			&i.ID,
			&i.WorkoutExerciseid,
			&i.Ordinal,
			&i.Weight,
			&i.Reps,
			&i.StaticHoldTime,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseSetsByWorkoutID = `-- name: GetExerciseSetsByWorkoutID :many
Select
    es.id,
    es.ordinal,
    es.workout_exerciseID,
    es.weight,
    es.reps,
    es.static_hold_time,
    es.created_at,
    es.modified_at
FROM
    exercise_sets es
JOIN workout_exercise we
    ON es.workout_exerciseID = we.id
JOIN workout_blocks wb
    ON we.workout_blockID = wb.id
JOIN workouts w
    ON wb.workoutid = w.id
WHERE
    w.id = $1
ORDER BY
    es.ordinal
`

type GetExerciseSetsByWorkoutIDRow struct {
	ID                uuid.UUID
	Ordinal           int32
	WorkoutExerciseid uuid.UUID
	Weight            float64
	Reps              sql.NullInt32
	StaticHoldTime    sql.NullInt32
	CreatedAt         sql.NullTime
	ModifiedAt        sql.NullTime
}

func (q *Queries) GetExerciseSetsByWorkoutID(ctx context.Context, id uuid.UUID) ([]GetExerciseSetsByWorkoutIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseSetsByWorkoutID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExerciseSetsByWorkoutIDRow
	for rows.Next() {
		var i GetExerciseSetsByWorkoutIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Ordinal,
			&i.WorkoutExerciseid,
			&i.Weight,
			&i.Reps,
			&i.StaticHoldTime,
			&i.CreatedAt,
			&i.ModifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
